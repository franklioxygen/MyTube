// Load environment variables from .env file
import dotenv from "dotenv";
dotenv.config();

import cors from "cors";
import express from "express";
import path from "path";
import {
  CLOUD_THUMBNAIL_CACHE_DIR,
  IMAGES_DIR,
  SUBTITLES_DIR,
  VIDEOS_DIR,
} from "./config/paths";
import { runMigrations } from "./db/migrate";
import { authMiddleware } from "./middleware/authMiddleware";
import { visitorModeMiddleware } from "./middleware/visitorModeMiddleware";
import { visitorModeSettingsMiddleware } from "./middleware/visitorModeSettingsMiddleware";
import apiRoutes from "./routes/api";
import settingsRoutes from "./routes/settingsRoutes";
import { cloudflaredService } from "./services/cloudflaredService";
import { getCachedThumbnail } from "./services/cloudStorage/cloudThumbnailCache";
import { CloudStorageService } from "./services/CloudStorageService";
import downloadManager from "./services/downloadManager";
import * as storageService from "./services/storageService";
import { logger } from "./utils/logger";
import {
  validateCloudThumbnailCachePath,
  validateRedirectUrl,
} from "./utils/security";
import { VERSION } from "./version";

// Display version information
VERSION.displayVersion();

const app = express();
const PORT = process.env.PORT || 5551;

// Security: Disable X-Powered-By header to prevent information disclosure
app.disable("x-powered-by");

// Middleware
app.use(cors());
// Increase body size limits for large file uploads (10GB)
app.use(express.json({ limit: "100gb" }));
app.use(express.urlencoded({ extended: true, limit: "100gb" }));

// Initialize storage (create directories, etc.)
// storageService.initializeStorage(); // Moved inside startServer

// Start the server
const startServer = async () => {
  try {
    // Run database migrations
    await runMigrations();

    // Initialize storage (create directories, etc.)
    storageService.initializeStorage();

    // Initialize download manager (restore queued tasks)
    downloadManager.initialize();

    // Serve static files with proper MIME types
    app.use(
      "/videos",
      express.static(VIDEOS_DIR, {
        setHeaders: (res, path) => {
          res.setHeader("Access-Control-Allow-Origin", "*");
          if (path.endsWith(".mp4")) {
            res.setHeader("Content-Type", "video/mp4");
          } else if (path.endsWith(".webm")) {
            res.setHeader("Content-Type", "video/webm");
          }
        },
      })
    );
    app.use(
      "/images",
      express.static(IMAGES_DIR, {
        setHeaders: (res) => {
          res.setHeader("Access-Control-Allow-Origin", "*");
        },
      })
    );
    app.use(
      "/api/cloud/thumbnail-cache",
      express.static(CLOUD_THUMBNAIL_CACHE_DIR)
    );
    app.use(
      "/subtitles",
      express.static(SUBTITLES_DIR, {
        setHeaders: (res, path) => {
          if (path.endsWith(".vtt")) {
            res.setHeader("Content-Type", "text/vtt");
            res.setHeader("Access-Control-Allow-Origin", "*");
          }
        },
      })
    );

    // Serve Frontend Static Files
    const frontendDist = path.join(__dirname, "../../frontend/dist");
    app.use(express.static(frontendDist));

    // Cloud storage redirect endpoints
    // Redirect /cloud/videos/* and /cloud/images/* to signed URLs (302 redirect)
    // This allows frontend to directly access cloud storage without going through server proxy
    // Browser will automatically handle Range requests when following the redirect
    // For thumbnails, check local cache first to avoid unnecessary redirects
    const redirectCloudFile = async (
      req: express.Request,
      res: express.Response,
      fileType: "video" | "image"
    ) => {
      try {
        const { filename } = req.params;
        const settings = storageService.getSettings();

        if (
          !settings.cloudDriveEnabled ||
          !settings.openListApiUrl ||
          !settings.openListToken
        ) {
          return res.status(404).send("Cloud storage not configured");
        }

        // For thumbnails, check local cache first
        // This reduces cloud storage API calls and improves performance
        if (fileType === "image") {
          const cloudPath = `cloud:${filename}`;
          const cachedPath = getCachedThumbnail(cloudPath);

          if (cachedPath) {
            // Serve from local cache directly (no redirect needed)
            // Security: cachedPath is generated by getCachedThumbnail which uses MD5 hash
            // of cloudPath, ensuring it's always within CLOUD_THUMBNAIL_CACHE_DIR
            // The path is safe and doesn't contain user input directly
            const validatedPath = validateCloudThumbnailCachePath(cachedPath);
            // Use root option to prevent path traversal - Express will ensure the file
            // is within the root directory, providing defense in depth
            const relativePath = path.relative(
              CLOUD_THUMBNAIL_CACHE_DIR,
              validatedPath
            );
            // Additional safety check: ensure relative path doesn't contain path traversal
            if (relativePath.includes("..") || path.isAbsolute(relativePath)) {
              logger.warn(
                `[CloudStorage] Suspicious relative path detected: ${relativePath}`
              );
              return res.status(500).send("Invalid file path");
            }
            return res.sendFile(relativePath, {
              root: CLOUD_THUMBNAIL_CACHE_DIR,
            });
          }
        }

        // Get signed URL from cloud storage service
        // This returns a direct URL to the cloud storage file with sign parameter
        const signedUrl = await CloudStorageService.getSignedUrl(
          filename,
          fileType === "video" ? "video" : "thumbnail"
        );

        if (!signedUrl) {
          return res.status(404).send("File not found in cloud storage");
        }

        // Validate that the signed URL is from the configured cloud storage domain
        // This prevents open redirect vulnerabilities by using an allowlist approach
        const apiBaseUrl = settings.openListApiUrl.replace("/api/fs/put", "");
        const publicUrl = settings.openListPublicUrl || apiBaseUrl;
        const allowedOrigin = new URL(publicUrl).origin;

        // Validate redirect URL against allowlist to prevent open redirect vulnerabilities
        // This uses an allowlist approach: only URLs from the configured cloud storage domain are allowed
        let validatedUrl: string;
        try {
          validatedUrl = validateRedirectUrl(signedUrl, allowedOrigin);
        } catch (validationError) {
          logger.warn(
            `[CloudStorage] Redirect URL validation failed: ${
              validationError instanceof Error
                ? validationError.message
                : String(validationError)
            }`
          );
          return res.status(500).send("Invalid cloud storage URL");
        }

        // Final safety check: ensure validatedUrl origin matches allowed origin
        // This redundant check helps static analysis tools understand the validation
        const validatedUrlObj = new URL(validatedUrl);
        if (validatedUrlObj.origin !== allowedOrigin) {
          logger.error(
            `[CloudStorage] Critical: Validated URL origin mismatch detected: ${validatedUrlObj.origin} != ${allowedOrigin}`
          );
          return res.status(500).send("Invalid cloud storage URL");
        }

        // Explicit allowlist pattern for static analysis tools
        // Build allowlist dynamically: only include the validated URL if it matches the allowed origin
        // This pattern matches what security scanners expect to see
        const allowedUrls: string[] = [];
        if (validatedUrlObj.origin === allowedOrigin) {
          // Only add to allowlist if origin matches exactly
          allowedUrls.push(validatedUrl);
        }

        // Check if URL is in allowlist before redirecting (explicit allowlist check pattern)
        const isAllowed = allowedUrls.includes(validatedUrl);
        if (!isAllowed) {
          logger.error(`[CloudStorage] URL not in allowlist: ${validatedUrl}`);
          return res.status(400).send("Invalid redirect URL");
        }

        // Get the URL from the allowlist to ensure it's the validated one
        // This makes it explicit to static analyzers that we're using an allowlist
        const redirectUrl = allowedUrls[0];
        if (!redirectUrl || redirectUrl !== validatedUrl) {
          return res.status(400).send("Invalid redirect URL");
        }

        // 302 redirect to the validated signed URL from allowlist
        // Browser will automatically follow the redirect and handle Range requests
        // This way, video data flows directly from cloud storage to client, bypassing our server
        // Security: redirectUrl comes from allowlist and is guaranteed to be from the allowed origin only
        res.redirect(302, redirectUrl);
      } catch (error: any) {
        logger.error(
          `Error redirecting cloud ${fileType}:`,
          error instanceof Error ? error : new Error(String(error))
        );
        if (!res.headersSent) {
          res.status(500).send(`Error fetching ${fileType} from cloud storage`);
        }
      }
    };

    app.get("/cloud/videos/:filename", (req, res) =>
      redirectCloudFile(req, res, "video")
    );
    app.get("/cloud/images/:filename", (req, res) =>
      redirectCloudFile(req, res, "image")
    );

    // API Routes
    // Apply auth middleware to all API routes
    app.use("/api", authMiddleware);
    // Apply visitor mode middleware to all API routes
    app.use("/api", visitorModeMiddleware, apiRoutes);
    // Use separate middleware for settings that allows disabling visitor mode
    app.use("/api/settings", visitorModeSettingsMiddleware, settingsRoutes);

    // SPA Fallback for Frontend
    app.get("*", (req, res) => {
      // Don't serve index.html for API calls that 404
      if (req.path.startsWith("/api") || req.path.startsWith("/cloud")) {
        res.status(404).send("Not Found");
        return;
      }
      res.sendFile(path.join(frontendDist, "index.html"));
    });

    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);

      // Start subscription scheduler
      import("./services/subscriptionService")
        .then(({ subscriptionService }) => {
          subscriptionService.startScheduler();
        })
        .catch((err) =>
          console.error("Failed to start subscription service:", err)
        );

      // Run duration backfill in background
      import("./services/metadataService")
        .then((service) => {
          service.backfillDurations();
        })
        .catch((err) =>
          console.error("Failed to start metadata service:", err)
        );

      // Start Cloudflared tunnel if enabled
      const settings = storageService.getSettings();
      if (settings.cloudflaredTunnelEnabled) {
        if (settings.cloudflaredToken) {
          cloudflaredService.start(settings.cloudflaredToken);
        } else {
          // Quick Tunnel
          const port = typeof PORT === "string" ? parseInt(PORT) : PORT;
          cloudflaredService.start(undefined, port);
        }
      }
    });
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
};

startServer();
